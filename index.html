<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Rhythm Dodger ‚Äì Auto Beat Detection [PHASE 2]</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
  body {
    margin: 0;
    background: #0a0a0a;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    color: white;
    font-family: sans-serif;
    overflow: hidden;
    position: relative;
  }
  #game-container {
    position: relative;
    display: inline-block;
    max-width: 100vw;
    max-height: 100vh;
  }
  canvas { 
    background: transparent;
    position: relative;
    z-index: 1;
    display: block;
    max-width: 100%;
    height: auto;
  }
  #bg-layer {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: -1;
    pointer-events: none;
    object-fit: cover;
    opacity: 0;
    transition: opacity 0.5s ease-in;
  }
  
  #bg-layer.playing {
    opacity: 0.3;
  }
  #lives-container {
    position: absolute;
    top: 50px;
    left: 20px;
    display: flex;
    gap: 15px;
    z-index: 10;
    pointer-events: none;
  }
  #progress-container {
    position: absolute;
    bottom: 80px;
    left: 20px;
    right: 20px;
    height: 8px;
    background: rgba(255, 255, 255, 0.15);
    border-radius: 4px;
    overflow: hidden;
    z-index: 10;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
  }
  #progress-fill {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, #ff0066, #ff3388, #00ddff);
    border-radius: 4px;
    transition: width 0.1s linear;
    box-shadow: 0 0 10px rgba(255, 0, 102, 0.5);
  }
  #progress-time {
    position: absolute;
    bottom: 92px;
    left: 20px;
    font-size: 13px;
    font-weight: 500;
    color: rgba(255, 255, 255, 0.9);
    text-shadow: 0 1px 4px rgba(0, 0, 0, 0.9);
    z-index: 10;
    font-family: monospace;
    display: none;
  }
  .heart {
    width: 40px;
    height: 40px;
    position: relative;
    animation: heartbeat 1.5s ease-in-out infinite;
  }
  .heart.lost {
    opacity: 0.2;
    animation: none;
    filter: grayscale(100%);
  }
  .heart.damage {
    animation: heartDamage 0.5s ease-out;
  }
  @keyframes heartbeat {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
  }
  @keyframes heartDamage {
    0% { transform: scale(1.5); filter: brightness(2); }
    50% { transform: scale(0.8) rotate(-10deg); }
    100% { transform: scale(1) rotate(0deg); }
  }
  #mobile-controls {
  position: fixed;
  bottom: 20px;
  left: 0;
  right: 0;
  display: none;
  justify-content: space-between;
  padding: 0 20px;
  z-index: 100;
  }
  #mobile-controls .control-button {
    position: relative;
    left: 0;
  }
  #mobile-controls .control-button#btn-right {
    left: auto;
    right: 0;
  }
  #mobile-controls.active {
    display: flex;
  }
  .control-button {
    width: 75px;
    height: 75px;
    background: linear-gradient(135deg, rgba(255, 0, 102, 0.25), rgba(255, 51, 136, 0.25));
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 32px;
    color: rgba(255, 255, 255, 0.7);
    user-select: none;
    -webkit-user-select: none;
    touch-action: manipulation;
    box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(3px);
    -webkit-backdrop-filter: blur(3px);
    opacity: 0.8;
  }
  .control-button:active {
    transform: scale(0.92);
    background: linear-gradient(135deg, rgba(255, 0, 102, 0.4), rgba(255, 51, 136, 0.4));
    color: rgba(255, 255, 255, 0.9);
  }
  .control-button:active {
    transform: scale(0.9);
    background: linear-gradient(135deg, rgba(255, 0, 102, 0.6), rgba(255, 51, 136, 0.6));
    box-shadow: 0 2px 10px rgba(255, 0, 102, 0.6);
    color: rgba(255, 255, 255, 0.9);
  }
  .control-button.pressed {
    transform: scale(0.9);
    background: linear-gradient(135deg, rgba(255, 0, 102, 0.4), rgba(255, 51, 136, 0.4));
    color: rgba(255, 255, 255, 0.9);
  }
  /* Game Over Screen */
  #game-over-screen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.85);
    display: none;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    z-index: 100;
    animation: fadeIn 0.5s ease-out;
  }
  #game-over-screen.show {
    display: flex;
  }
  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  .game-over-content {
    text-align: center;
    animation: slideUp 0.5s ease-out;
  }
  @keyframes slideUp {
    from { transform: translateY(50px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
  }
  .game-over-title {
    font-size: 60px;
    font-weight: bold;
    color: #ff0066;
    margin-bottom: 20px;
    text-shadow: 0 0 20px rgba(255, 0, 102, 0.8);
  }
  .game-over-phase {
    font-size: 24px;
    color: #00ddff;
    margin-bottom: 30px;
    display: none;
  }
  .retry-button {
    background: linear-gradient(135deg, #ff0066, #ff3388);
    color: white;
    border: none;
    padding: 15px 50px;
    font-size: 24px;
    font-weight: bold;
    border-radius: 10px;
    cursor: pointer;
    box-shadow: 0 5px 20px rgba(255, 0, 102, 0.5);
    transition: all 0.3s ease;
    margin-top: 20px;
  }
  .retry-button:hover {
    transform: scale(1.1);
    box-shadow: 0 8px 30px rgba(255, 0, 102, 0.8);
  }
  .retry-button:active {
    transform: scale(0.95);
  }
  #screen-glow {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 0;
    opacity: 0;
    transition: opacity 0.03s ease-out;
    mix-blend-mode: screen;
  }
  #screen-glow.active {
    opacity: 1;
  }
  /* Victory Screen */
#victory-screen {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.9);
  display: none;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  z-index: 100;
  animation: fadeIn 0.5s ease-out;
}
#victory-screen.show {
  display: flex;
}
.victory-content {
  text-align: center;
  animation: slideUp 0.5s ease-out;
  max-width: 80%;
  padding: 20px;
}
.victory-title {
  font-size: 70px;
  font-weight: bold;
  background: linear-gradient(45deg, #ff0066, #00ddff, #00ff88);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin-bottom: 30px;
  animation: victoryGlow 2s ease-in-out infinite;
  filter: drop-shadow(0 0 30px rgba(0, 221, 255, 0.6));
}
@keyframes victoryGlow {
  0%, 100% { filter: brightness(1) drop-shadow(0 0 30px rgba(0, 221, 255, 0.6)); }
  50% { filter: brightness(1.5) drop-shadow(0 0 50px rgba(0, 221, 255, 0.9)); }
}
.victory-stats {
  font-size: 18px;
  color: #00ff88;
  margin: 15px 0 25px 0;
  line-height: 1.6;
}
.victory-message {
  font-size: 18px;
  color: #ffffff;
  line-height: 1.8;
  margin: 20px 0;
  padding: 25px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 10px;
  border: 2px solid rgba(0, 221, 255, 0.3);
  white-space: pre-wrap;
  max-height: 400px;
  overflow-y: auto;
  box-shadow: 0 0 20px rgba(0, 221, 255, 0.2);
}

/* Mobile responsiveness for victory screen */
@media (max-width: 768px) {
  .victory-title {
    font-size: 50px;
  }
  .victory-message {
    font-size: 16px;
    padding: 20px;
    max-height: 300px;
  }
}

@media (max-width: 480px) {
  .victory-title {
    font-size: 40px;
  }
  .victory-stats {
    font-size: 16px;
  }
  .victory-message {
    font-size: 14px;
    padding: 15px;
  }
}

  /* Loading Screen */
  #loading {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    background: rgba(0,0,0,0.9);
    padding: 30px 50px;
    border-radius: 10px;
    border: 2px solid #00ddff;
    max-width: 400px;
    z-index: 10;
  }
  #loading h2 {
    margin: 0 0 15px 0;
    color: #00ddff;
  }
  #progress {
    width: 300px;
    height: 20px;
    background: #222;
    border-radius: 10px;
    overflow: hidden;
    margin: 15px 0;
  }
  #progress-bar {
    height: 100%;
    background: linear-gradient(90deg, #00ddff, #00ff88);
    width: 0%;
    transition: width 0.3s;
  }
  .status {
    font-size: 14px;
    color: #aaa;
    margin-top: 10px;
  }
  /* Main Menu Screen */
  #main-menu {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.9);
    display: none;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    z-index: 10;
    animation: fadeIn 0.5s ease-out;
  }
  #main-menu.show {
    display: flex;
  }
  /* Neon Title */
  .neon-title {
    font-size: 80px;
    font-weight: bold;
    text-align: center;
    margin-bottom: 60px;
    font-family: 'Arial Black', sans-serif;
    letter-spacing: 8px;
    animation: neonPulse 2s ease-in-out infinite;
  }
  .neon-title span:nth-child(1) {
    color: #ff0066;
    text-shadow: 
      0 0 10px #ff0066,
      0 0 20px #ff0066,
      0 0 30px #ff0066,
      0 0 40px #ff0066,
      0 0 70px #ff0066,
      0 0 80px #ff0066,
      0 0 100px #ff0066;
  }
  .neon-title span:nth-child(2) {
    color: #00ddff;
    text-shadow: 
      0 0 10px #00ddff,
      0 0 20px #00ddff,
      0 0 30px #00ddff,
      0 0 40px #00ddff,
      0 0 70px #00ddff,
      0 0 80px #00ddff,
      0 0 100px #00ddff;
  }
  @keyframes neonPulse {
    0%, 100% {
      filter: brightness(1);
    }
    50% {
      filter: brightness(1.3);
    }
  }
  /* Menu Buttons */
  .menu-button {
    background: linear-gradient(135deg, #ff0066, #ff3388);
    color: white;
    border: 3px solid rgba(255, 255, 255, 0.3);
    padding: 20px 80px;
    font-size: 32px;
    font-weight: bold;
    border-radius: 15px;
    cursor: pointer;
    box-shadow: 0 5px 20px rgba(255, 0, 102, 0.5);
    transition: all 0.3s ease;
    margin: 15px 0;
    text-transform: uppercase;
    letter-spacing: 2px;
    user-select: none;
  }
  .menu-button:hover {
    transform: scale(1.05);
    box-shadow: 0 8px 30px rgba(255, 0, 102, 0.8);
    border-color: rgba(255, 255, 255, 0.6);
  }
  .menu-button:active {
    transform: scale(0.98);
  }
  .menu-button.quality-button {
    background: linear-gradient(135deg, #00ddff, #00aacc);
    box-shadow: 0 5px 20px rgba(0, 221, 255, 0.5);
    font-size: 24px;
    padding: 15px 60px;
  }
  .menu-button.quality-button:hover {
    box-shadow: 0 8px 30px rgba(0, 221, 255, 0.8);
  }
  .quality-indicator {
    font-size: 16px;
    color: #00ff88;
    margin-top: 5px;
    font-weight: normal;
  }
  
  /* Main Menu Responsive Design */
  @media (max-width: 768px) {
    .neon-title {
      font-size: 60px;
      margin-bottom: 40px;
    }
    
    .menu-button {
      padding: 15px 60px;
      font-size: 28px;
      margin: 10px 0;
    }
    
    .menu-button.quality-button {
      font-size: 20px;
      padding: 12px 45px;
    }
    
    #main-menu {
      padding: 20px;
    }
  }
  @media (max-width: 768px) {
    * {
      -webkit-transform: translateZ(0);
      transform: translateZ(0);
    }
    
    .heart {
      animation: none !important;
    }
    
    .neon-title {
      animation: none !important;
    }
    
    #bg-layer {
      display: none !important;
    }
    
    .control-button {
      backdrop-filter: none !important;
      -webkit-backdrop-filter: none !important;
    }
  }
  @media (max-width: 480px) {
    .neon-title {
      font-size: 45px;
      margin-bottom: 30px;
    }
    
    .neon-title span {
      letter-spacing: 3px;
    }
    
    .menu-button {
      width: 90%;
      padding: 12px 20px;
      font-size: 24px;
      margin: 8px 0;
    }
    
    .menu-button.quality-button {
      font-size: 18px;
      padding: 10px 20px;
    }
    
    #game-container {
      max-width: 100%;
      overflow: hidden;
    }
    
    canvas {
      max-width: 100%;
      height: auto !important;
    }
  }
  
  /* Hide lives on main menu and game over screens */
  #main-menu.show ~ #game-container #lives-container,
  #game-over-screen.show + #lives-container {
    display: none;
  }
</style>
</head>
<body>
<div id="screen-glow"></div>
<div id="loading">
  <h2>üéµ Analyzing Beat...</h2>
  <div id="progress">
    <div id="progress-bar"></div>
  </div>
  <div class="status" id="status">Initializing...</div>
  <div style="font-size: 12px; color: #666; margin-top: 15px;">
    Please be patient
  </div>
</div>
<!-- Main Menu -->
<div id="main-menu">
  <div class="neon-title">
    <span>RUEERA</span><br>
    <span>RHYTM DODGER</span>
  </div>
  <button class="menu-button" id="play-button" onclick="startGameFromMenu()">
    ‚ñ∂ PLAY
  </button>
  <button class="menu-button quality-button" id="quality-button" onclick="toggleQuality()">
    <div>‚öô QUALITY</div>
    <div class="quality-indicator" id="quality-text">HIGH</div>
  </button>
</div>
<div id="game-container">
  <video id="bg-layer" loop muted playsinline></video>
  <div id="lives-container">
    <svg class="heart" viewBox="0 0 100 100">
      <path d="M50,90 C50,90 10,60 10,35 C10,20 20,10 32,10 C40,10 47,15 50,22 C53,15 60,10 68,10 C80,10 90,20 90,35 C90,60 50,90 50,90 Z" 
            fill="#ff0066" stroke="#cc0044" stroke-width="3"/>
    </svg>
    <svg class="heart" viewBox="0 0 100 100">
      <path d="M50,90 C50,90 10,60 10,35 C10,20 20,10 32,10 C40,10 47,15 50,22 C53,15 60,10 68,10 C80,10 90,20 90,35 C90,60 50,90 50,90 Z" 
            fill="#ff0066" stroke="#cc0044" stroke-width="3"/>
    </svg>
    <svg class="heart" viewBox="0 0 100 100">
      <path d="M50,90 C50,90 10,60 10,35 C10,20 20,10 32,10 C40,10 47,15 50,22 C53,15 60,10 68,10 C80,10 90,20 90,35 C90,60 50,90 50,90 Z" 
            fill="#ff0066" stroke="#cc0044" stroke-width="3"/>
    </svg>
  </div>
  <div id="game-over-screen">
    <div class="game-over-content">
      <div class="game-over-title">SKILL ISSUE</div>
      <div class="game-over-phase" id="phase-text"></div>
      <button class="retry-button" onclick="restart()">RETRY</button>
    </div>
  </div>
  <!-- Victory Screen -->
<div id="victory-screen">
  <div class="victory-content">
    <div class="victory-title">COOL U WIN EAT KEY NOW</div>
    <div class="victory-stats" id="victory-stats"></div>
    <div class="victory-message" id="victory-message">Loading your reward...</div>
    <button class="retry-button" onclick="restart()">PLAY AGAIN</button>
  </div>
</div>
  <div id="mobile-controls">
    <div class="control-button" id="btn-left">‚óÑ</div>
    <div class="control-button" id="btn-right">‚ñ∫</div>
  </div>
  <div id="progress-container">
    <div id="progress-fill"></div>
  </div>
  <div id="progress-time">0:00 / 0:00</div>
  <audio id="music" preload="auto"></audio>
  <audio id="sfx" preload="auto"></audio>
  <canvas id="game" width="600" height="800"></canvas>
</div>
<canvas id="items-overlay" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 20;"></canvas>
<script>
  /* ================= ANTI-INSPECT PROTECTION ================= */
// Disable right-click
document.addEventListener('contextmenu', e => e.preventDefault());

// Disable common inspect shortcuts
document.addEventListener('keydown', e => {
  // F12
  if (e.key === 'F12') {
    e.preventDefault();
    return false;
  }
  
  // Ctrl+Shift+I
  if (e.ctrlKey && e.shiftKey && e.key === 'I') {
    e.preventDefault();
    return false;
  }
  
  // Ctrl+Shift+J
  if (e.ctrlKey && e.shiftKey && e.key === 'J') {
    e.preventDefault();
    return false;
  }
  
  // Ctrl+U (view source)
  if (e.ctrlKey && e.key === 'u') {
    e.preventDefault();
    return false;
  }
  
  // Ctrl+Shift+C
  if (e.ctrlKey && e.shiftKey && e.key === 'C') {
    e.preventDefault();
    return false;
  }
});
// Detect if DevTools is open
let devtoolsOpen = false;
const detectDevTools = () => {
  const threshold = 160;
  const widthThreshold = window.outerWidth - window.innerWidth > threshold;
  const heightThreshold = window.outerHeight - window.innerHeight > threshold;
  
  if (widthThreshold || heightThreshold) {
    if (!devtoolsOpen) {
      devtoolsOpen = true;
      handleDevToolsOpen();
    }
  } else {
    devtoolsOpen = false;
  }
};

function handleDevToolsOpen() {
  // Redirect to nope.html
  window.location.href = 'nope.html';
}

// Check every 500ms
setInterval(detectDevTools, 500);
/* ================= QUALITY SETTINGS ================= */
let isHighQuality = true;
// Quality settings
// Change particle limits for mobile
const QUALITY_SETTINGS = {
  high: {
    maxParticles: isMobile ? 15 : 100,
    collisionParticles: isMobile ? 5 : 30,
    dissolveParticles: isMobile ? 8 : 40,
    laserLayers: isMobile ? 1 : 5,
    particleDecay: isMobile ? 0.05 : 0.015,
    enableShadows: isMobile ? false : true,
    speedBonus: 0
  },
  low: {
    maxParticles: 15,
    collisionParticles: 5,
    dissolveParticles: 8,
    laserLayers: 1,
    particleDecay: 0.08,
    enableShadows: false,
    speedBonus: 1
  }
};
let currentQuality = QUALITY_SETTINGS.high;
function toggleQuality() {
  isHighQuality = !isHighQuality;
  currentQuality = isHighQuality ? QUALITY_SETTINGS.high : QUALITY_SETTINGS.low;
  const qualityText = document.getElementById('quality-text');
  qualityText.textContent = isHighQuality ? 'HIGH' : 'LOW';
  console.log(`Quality switched to: ${isHighQuality ? 'HIGH' : 'LOW'}`);
}
/* ================= CORE ================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d", {
  alpha: true,
  desynchronized: true,
  willReadFrequently: false
});

// Lower resolution on mobile for huge performance boost
if (isMobile) {
  const scale = 0.7; // 70% resolution
  canvas.style.width = '600px';
  canvas.style.height = '800px';
  canvas.width = 420;  // 600 * 0.7
  canvas.height = 560; // 800 * 0.7
}
const itemsCanvas = document.getElementById("items-overlay");
const itemsCtx = itemsCanvas.getContext("2d");

// Set items canvas to match viewport size
itemsCanvas.width = window.innerWidth;
itemsCanvas.height = window.innerHeight;

// Calculate offset for items (game canvas position relative to viewport)
function getGameCanvasOffset() {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  return { 
    offsetX: rect.left, 
    offsetY: rect.top,
    scaleX: rect.width / canvas.width,
    scaleY: rect.height / canvas.height
  };
}

const audio = document.getElementById("music");
const sfxAudio = document.getElementById("sfx");
const loadingDiv = document.getElementById("loading");
const statusDiv = document.getElementById("status");
const progressBar = document.getElementById("progress-bar");
const screenGlow = document.getElementById("screen-glow");
const hearts = document.querySelectorAll('.heart');
const gameOverScreen = document.getElementById("game-over-screen");
const phaseText = document.getElementById("phase-text");
const mobileControls = document.getElementById("mobile-controls");
const btnLeft = document.getElementById("btn-left");
const btnRight = document.getElementById("btn-right");
const progressFill = document.getElementById("progress-fill");
const progressTime = document.getElementById("progress-time");
const mainMenu = document.getElementById("main-menu");

/* ================= VIDEO BACKGROUND ================= */
const bgVideo = document.getElementById("bg-layer");
bgVideo.src = 'bg.mp4';
bgVideo.volume = 0; // Ensure muted
bgVideo.addEventListener('error', () => {
  console.warn("‚ö†Ô∏è bg.mp4 not found - background will be black");
});
bgVideo.addEventListener('loadeddata', () => {
  console.log("‚úì Background video loaded successfully!");
});

/* ================= ITEM IMAGE PRELOAD ================= */
const itemImage = new Image();
itemImage.src = 'item.png';
itemImage.onerror = () => {
  console.warn("‚ö†Ô∏è item.png not found - items will render as colored squares");
};
itemImage.onload = () => {
  console.log("‚úì item.png loaded successfully!");
};

/* ================= SFX SYSTEM ================= */
let impactSoundsPlaying = new Set();
let sfxLoaded = false;
sfxAudio.src = 'sfx.mp3';
sfxAudio.addEventListener('canplaythrough', () => {
  sfxLoaded = true;
  console.log("‚úì SFX loaded successfully!");
}, { once: true });
sfxAudio.addEventListener('error', (e) => {
  console.warn("‚ö†Ô∏è sfx.mp3 not found - SFX will be disabled");
  sfxLoaded = false;
}, { once: true });
function playImpactSound() {
  if (!sfxLoaded) return;
  try {
    const sfx = new Audio('sfx.mp3');
    const randomPitch = 0.7 + Math.random() * 0.8;
    sfx.playbackRate = randomPitch;
    sfx.volume = 0.5;
    sfx.play().catch(err => {});
    sfx.addEventListener('ended', () => sfx.remove());
  } catch (err) {}
}
/* ================= MOBILE DETECTION & CONTROLS ================= */
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                 (navigator.maxTouchPoints && navigator.maxTouchPoints > 2);
if (isMobile) {
  mobileControls.classList.add('active');
}
/* ================= PROGRESS BAR ================= */
function updateProgressBar() {
  if (!audio || !audio.duration || isNaN(audio.duration)) return;
  const currentTime = audio.currentTime;
  const duration = audio.duration;
  const progress = (currentTime / duration) * 100;
  progressFill.style.width = progress + '%';
  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };
  progressTime.textContent = `${formatTime(currentTime)} / ${formatTime(duration)}`;
}
let mobileLeftPressed = false;
let mobileRightPressed = false;
btnLeft.addEventListener('touchstart', (e) => {
  e.preventDefault();
  mobileLeftPressed = true;
  btnLeft.classList.add('pressed');
});
btnLeft.addEventListener('touchend', (e) => {
  e.preventDefault();
  mobileLeftPressed = false;
  btnLeft.classList.remove('pressed');
});
btnLeft.addEventListener('touchcancel', (e) => {
  e.preventDefault();
  mobileLeftPressed = false;
  btnLeft.classList.remove('pressed');
});
btnRight.addEventListener('touchstart', (e) => {
  e.preventDefault();
  mobileRightPressed = true;
  btnRight.classList.add('pressed');
});
btnRight.addEventListener('touchend', (e) => {
  e.preventDefault();
  mobileRightPressed = false;
  btnRight.classList.remove('pressed');
});
btnRight.addEventListener('touchcancel', (e) => {
  e.preventDefault();
  mobileRightPressed = false;
  btnRight.classList.remove('pressed');
});
/* ================= SETTINGS ================= */
const BLOCK_SPEED = 8;
let BEAT_TIMES = [];
let CURRENT_BEAT_INDEX = 0;
const LANE_COUNT = 5;
const GAP_SIZE = 2.5;
const MIN_SAFE_LANES = 1;
const PLATFORM_Y = 680;
const PLATFORM_HEIGHT = 30;
const PLATFORM_MARGIN = 80;
const PLATFORM_WIDTH = canvas.width - PLATFORM_MARGIN * 2;
const PLATFORM_X = PLATFORM_MARGIN;
const LANE_WIDTH = PLATFORM_WIDTH / LANE_COUNT;
const FPS = 60;
const FRAME_TIME = 1000 / FPS;
const START_DELAY = 1000;
/* ================= LIVES SYSTEM ================= */
let playerLives = 3;
let isInvulnerable = false;
let invulnerabilityTimer = 0;
const INVULNERABILITY_DURATION = 2000;
const FREEZE_DURATION = 2000;
const DISSOLVE_DURATION = 2000;
let deathAnimationTimeouts = [];
let isDeathAnimationPlaying = false;

function loseLife() {
  if (isInvulnerable || playerLives <= 0 || gameOver) return;
  playerLives--;
  
  // Clear any existing death animations if we're starting fresh
  if (playerLives <= 0 && !isDeathAnimationPlaying) {
    deathAnimationTimeouts.forEach(timeout => clearTimeout(timeout));
    deathAnimationTimeouts = [];
  }
  
  // Update heart display
  const heartIndex = playerLives;
  if (hearts[heartIndex]) {
    hearts[heartIndex].classList.add('damage');
    setTimeout(() => {
      if (hearts[heartIndex]) {
        hearts[heartIndex].classList.add('lost');
        hearts[heartIndex].classList.remove('damage');
      }
    }, 500);
  }
  
  if (playerLives <= 0) {
    if (isDeathAnimationPlaying || gameOver) return;
    
    // Start death animation sequence
    isDeathAnimationPlaying = true;
    gameOver = false; // Not game over until animation completes
    audio.pause();
    allowSpawning = false;
    
    // Clear entities
    bullets = [];
    lasers = [];
    
    // First freeze effect
    isFreezing = true;
    freezeStartTime = Date.now();
    
    // Schedule the dissolve particles
    const freezeTimeout = setTimeout(() => {
      if (!isDeathAnimationPlaying) return;
      isFreezing = false;
      createDissolveParticles(player.x, player.y, player.width);
    }, FREEZE_DURATION);
    
    deathAnimationTimeouts.push(freezeTimeout);
    
    // Schedule the game over screen
    const gameOverTimeout = setTimeout(() => {
      isDeathAnimationPlaying = false;
      isFreezing = false;
      gameOver = true;
      phaseText.textContent = currentPhase === 2 ? "Phase 2" : "Phase 1";
      gameOverScreen.classList.add('show');
    }, FREEZE_DURATION + DISSOLVE_DURATION);
    
    deathAnimationTimeouts.push(gameOverTimeout);
    return;
  }
  
  // Invulnerability handling
  isInvulnerable = true;
  invulnerabilityTimer = Date.now();
}
/* ================= PHASE 2 SETTINGS ================= */
const PHASE_2_TRIGGER_TIME = 60000;
let currentPhase = 1;
let phase2Activated = false;
let currentBlockSpeed = BLOCK_SPEED;
let phase2TransitionTime = 0;
let phase2Warning = false;
/* ================= SCREEN GLOW SYSTEM ================= */
let activeGlows = [];
function triggerScreenGlow(hue) {
  activeGlows.push({
    hue: hue,
    intensity: 1.0,
    decay: 0.88
  });
  updateScreenGlow();
}
function updateScreenGlow() {
  for (let i = activeGlows.length - 1; i >= 0; i--) {
    activeGlows[i].intensity *= activeGlows[i].decay;
    if (activeGlows[i].intensity < 0.01) {
      activeGlows.splice(i, 1);
    }
  }
  if (activeGlows.length > 0) {
    let totalIntensity = 0;
    let avgHue = 0;
    activeGlows.forEach(glow => {
      totalIntensity += glow.intensity;
      avgHue += glow.hue * glow.intensity;
    });
    avgHue /= totalIntensity;
    totalIntensity = Math.min(totalIntensity * 1.5, 1.5);
    if (isHighQuality) {
      screenGlow.style.background = `radial-gradient(circle at center, 
        hsla(${avgHue}, 100%, 65%, ${totalIntensity * 0.7}) 0%, 
        hsla(${avgHue}, 100%, 60%, ${totalIntensity * 0.55}) 20%,
        hsla(${avgHue}, 100%, 55%, ${totalIntensity * 0.4}) 40%,
        hsla(${avgHue}, 100%, 50%, ${totalIntensity * 0.25}) 60%,
        hsla(${avgHue}, 100%, 45%, 0) 80%)`;
    } else {
      screenGlow.style.background = `radial-gradient(circle at center, 
        hsla(${avgHue}, 100%, 65%, ${totalIntensity * 0.5}) 0%, 
        hsla(${avgHue}, 100%, 50%, 0) 60%)`;
    }
    screenGlow.classList.add('active');
  } else {
    screenGlow.classList.remove('active');
  }
}
/* ================= PARTICLE SYSTEM ================= */
let particles = [];
let dissolveParticles = [];
function createDissolveParticles(x, y, size) {
  if (isNaN(x) || isNaN(y) || isNaN(size)) return;
  const centerX = x + size / 2;
  const centerY = y + size / 2;
  const particleCount = currentQuality.dissolveParticles;
  for (let i = 0; i < particleCount; i++) {
    const angle = Math.random() * Math.PI * 2;
    const distance = Math.random() * 3;
    const speed = 0.5 + Math.random() * 1.5;
    dissolveParticles.push({
      x: centerX + Math.cos(angle) * distance,
      y: centerY + Math.sin(angle) * distance,
      vx: Math.cos(angle) * speed * 0.5,
      vy: -Math.abs(Math.sin(angle) * speed) - 0.5,
      size: 2 + Math.random() * 4,
      life: 1.0,
      decay: 0.003 + Math.random() * 0.003,
      rotation: Math.random() * Math.PI * 2,
      rotationSpeed: (Math.random() - 0.5) * 0.1,
      brightness: 0.7 + Math.random() * 0.3
    });
  }
}
function updateAndDrawDissolveParticles() {
  for (let i = dissolveParticles.length - 1; i >= 0; i--) {
    const p = dissolveParticles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vx *= 0.98;
    p.vy += -0.02;
    p.rotation += p.rotationSpeed;
    p.life -= p.decay;
    if (p.life <= 0) {
      dissolveParticles.splice(i, 1);
      continue;
    }
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    ctx.translate(p.x, p.y);
    ctx.rotate(p.rotation);
    if (isHighQuality) {
      const glowSize = p.size * 4 * p.life;
      const glowGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize);
      glowGrad.addColorStop(0, `rgba(255, ${Math.floor(51 * p.brightness)}, ${Math.floor(136 * p.brightness)}, ${p.life * 0.6})`);
      glowGrad.addColorStop(0.5, `rgba(255, ${Math.floor(0 * p.brightness)}, ${Math.floor(102 * p.brightness)}, ${p.life * 0.3})`);
      glowGrad.addColorStop(1, `rgba(255, 0, 102, 0)`);
      ctx.fillStyle = glowGrad;
      ctx.fillRect(-glowSize, -glowSize, glowSize * 2, glowSize * 2);
      ctx.shadowBlur = 10 * p.life;
      ctx.shadowColor = `rgba(255, 0, 102, ${p.life * 0.8})`;
    }
    ctx.beginPath();
    ctx.arc(0, 0, p.size * p.life * 0.7, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(255, ${Math.floor(102 * p.brightness * p.life)}, ${Math.floor(136 * p.brightness * p.life)}, ${p.life * 0.9})`;
    ctx.fill();
    ctx.restore();
  }
}
function createCollisionParticles(x, y, width, hue) {
  if (particles.length > currentQuality.maxParticles) return;
  const particleCount = currentQuality.collisionParticles;
  const centerX = x + width / 2;
  for (let i = 0; i < particleCount; i++) {
    const angle = (Math.PI / 180) * (Math.random() * 180 - 90);
    const speed = 3 + Math.random() * 8;
    const size = 3 + Math.random() * 6;
    particles.push({
      x: centerX,
      y: y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed - 2,
      size: size,
      life: 1.0,
      decay: currentQuality.particleDecay + Math.random() * currentQuality.particleDecay,
      hue: hue + (Math.random() * 20 - 10),
      rotation: Math.random() * Math.PI * 2,
      rotationSpeed: (Math.random() - 0.5) * 0.3
    });
  }
}
function updateAndDrawParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.3;
    p.vx *= 0.98;
    p.rotation += p.rotationSpeed;
    p.life -= p.decay;
    if (p.life <= 0) {
      particles.splice(i, 1);
      continue;
    }
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    ctx.translate(p.x, p.y);
    ctx.rotate(p.rotation);
  if (isHighQuality && !isMobile) {
      const glowSize = p.size * 3;
      const glowGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize);
      glowGrad.addColorStop(0, `hsla(${p.hue}, 100%, 70%, ${p.life * 0.6})`);
      glowGrad.addColorStop(0.5, `hsla(${p.hue}, 100%, 60%, ${p.life * 0.3})`);
      glowGrad.addColorStop(1, `hsla(${p.hue}, 100%, 50%, 0)`);
      ctx.fillStyle = glowGrad;
      ctx.fillRect(-glowSize, -glowSize, glowSize * 2, glowSize * 2);
      ctx.shadowBlur = 15;
      ctx.shadowColor = `hsl(${p.hue}, 100%, 60%)`;
    }
    ctx.fillStyle = `hsl(${p.hue}, 100%, ${60 + p.life * 20}%)`;
    ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
    ctx.restore();
  }
}
/* ================= GAME STATE ================= */
let bullets = [];
let lasers = [];
let gameOver = false;
let gameStarted = false;
let analysisComplete = false;
let allowSpawning = false;
let startDelayTimer = null;
let isFreezing = false;
let freezeStartTime = 0;
let frameCount = 0;
let scheduledBeats = new Set();
let laneReservations = Array(LANE_COUNT).fill(0);
let beatPulse = 0;
let audioStarted = false;
let victoryTriggered = false;
let frameSkipCounter = 0;
const getVictoryURL = () => {
   const encoded = 'aHR0cHM6Ly9naXN0LmdpdGh1YnVzZXJjb250ZW50LmNvbS9SVTNSNDE3My9kNTA5M2RlNWQzMzU0NTM0NGMxOGVjMjAwZmY5ZTdhOS9yYXcvZGJiMWU3OTE4NjNjYmI3N2YyZWI5M2ZjY2RkOTc5YWRkZjk0MjM5Zi9naXN0ZmlsZTEudHh0';
  return atob(encoded);
};
/* ================= ITEM THROWING SYSTEM ================= */
let thrownItems = [];
let lastItemThrowTime = 0;
const ITEM_THROW_INTERVAL = 10000; 

function throwItem(side) {
  const throwX = side === 'left' ? PLATFORM_MARGIN / 2 : canvas.width - PLATFORM_MARGIN / 2;
  const throwY = canvas.height - 100;
  thrownItems.push({
    x: throwX,
    y: throwY,
    vy: -15,
    rotation: 0,
    rotationSpeed: (Math.random() - 0.5) * 0.3,
    side: side,
    life: 1.0,
    gravity: 0.5
  });
}
function throwBothSides() {
  throwItem('left');
  throwItem('right');
}
function updateAndDrawItems() {
  // Clear the items overlay canvas
  itemsCtx.clearRect(0, 0, itemsCanvas.width, itemsCanvas.height);
  
  // Get game canvas position and scale
  const offset = getGameCanvasOffset();
  
  for (let i = thrownItems.length - 1; i >= 0; i--) {
    const item = thrownItems[i];
    if (!item) continue; // Safety check
    
    item.vy += item.gravity;
    item.y += item.vy;
    item.rotation += item.rotationSpeed;
    
    if (item.y > canvas.height + 150) {
      thrownItems.splice(i, 1);
      continue;
    }
    
    // Convert game canvas coordinates to viewport coordinates
    const screenX = offset.offsetX + (item.x * offset.scaleX);
    const screenY = offset.offsetY + (item.y * offset.scaleY);
    const screenSize = 180 * offset.scaleX;
    
    itemsCtx.save();
    itemsCtx.translate(screenX, screenY);
    itemsCtx.rotate(item.rotation);
    if (itemImage.complete && itemImage.naturalWidth > 0) {
      itemsCtx.drawImage(itemImage, -screenSize/2, -screenSize/2, screenSize, screenSize);
    } else {
      itemsCtx.fillStyle = '#00FFCC';
      itemsCtx.fillRect(-screenSize/2, -screenSize/2, screenSize, screenSize);
    }
    itemsCtx.restore();
  }
}
function checkItemThrow() {
  if (!gameStarted || gameOver || isDeathAnimationPlaying) return;
  const currentTime = Date.now();
  if (currentTime - lastItemThrowTime >= ITEM_THROW_INTERVAL) {
    throwBothSides();
    lastItemThrowTime = currentTime;
  }
}
/* ================= PLAYER ================= */
const player = {
  x: PLATFORM_X + PLATFORM_WIDTH / 2,
  y: PLATFORM_Y - 20,
  width: 24,
  height: 24,
  vx: 0,
  vy: 0,
  accel: 1.3,
  friction: 0.88,
  maxSpeed: 12,
  gravity: 0.6,
  jumpPower: -12,
  isGrounded: false
};
const HIT_Y = PLATFORM_Y;
/* ================= DRAW HEART-SHAPED PLAYER ================= */
function drawHeartPlayer(x, y, size) {
  if (isFreezing) {
    const elapsed = Date.now() - freezeStartTime;
    if (elapsed < FREEZE_DURATION) {
      drawHeartShape(x, y, size);
      return;
    }
  }
  if (isDeathAnimationPlaying && !isFreezing) return;
  if (gameOver && !isFreezing) return;
  const currentTime = Date.now();
  if (isInvulnerable) {
    const elapsed = currentTime - invulnerabilityTimer;
    if (elapsed >= INVULNERABILITY_DURATION) {
      isInvulnerable = false;
    } else {
      const flashSpeed = 100;
      if (Math.floor(elapsed / flashSpeed) % 2 === 0) {
        return;
      }
    }
  }
  drawHeartShape(x, y, size);
}
function drawHeartShape(x, y, size) {
  const centerX = x + size / 2;
  const centerY = y + size / 2;
  ctx.save();
  ctx.translate(centerX, centerY);
  ctx.beginPath();
  const scale = size / 24;
  ctx.moveTo(0, -6 * scale);
  ctx.bezierCurveTo(-12 * scale, -12 * scale, -12 * scale, -4 * scale, -12 * scale, 2 * scale);
  ctx.bezierCurveTo(-12 * scale, 6 * scale, -8 * scale, 10 * scale, 0, 14 * scale);
  ctx.bezierCurveTo(8 * scale, 10 * scale, 12 * scale, 6 * scale, 12 * scale, 2 * scale);
  ctx.bezierCurveTo(12 * scale, -4 * scale, 12 * scale, -12 * scale, 0, -6 * scale);
  ctx.closePath();
  if (currentQuality.enableShadows) {
    ctx.shadowBlur = 20;
    ctx.shadowColor = '#ff0066';
  }
  ctx.fillStyle = '#ff0066';
  ctx.fill();
  if (currentQuality.enableShadows) {
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#ff3388';
  }
  ctx.fillStyle = '#ff3388';
  ctx.fill();
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 2;
  ctx.stroke();
  ctx.shadowBlur = 0;
  ctx.restore();
}
/* ================= COLOR PALETTE ================= */
function getHueForPhase() {
  if (currentPhase === 1) {
    const colors = [45, 50, 55, 340, 350, 355, 30, 40];
    return colors[Math.floor(Math.random() * colors.length)] + (Math.random() * 8 - 4);
  } else {
    const mikuColors = [180, 175, 170, 165, 185, 190, 160];
    return mikuColors[Math.floor(Math.random() * mikuColors.length)] + (Math.random() * 10 - 5);
  }
}
/* ================= PHASE 2 FUNCTIONS ================= */
function activatePhase2() {
  if (phase2Activated) return;
  phase2Activated = true;
  currentPhase = 2;
  phase2TransitionTime = Date.now();
  currentBlockSpeed = BLOCK_SPEED + 1;
}
function checkPhase2Trigger() {
  if (!phase2Activated && audio.currentTime * 1000 >= PHASE_2_TRIGGER_TIME) {
    activatePhase2();
  }
}
/* ================= VICTORY DETECTION ================= */
function checkVictoryCondition() {
  if (victoryTriggered || !gameStarted || gameOver || isDeathAnimationPlaying) return;
  
  // Check if song is almost finished (within 0.5 seconds of end) and player is alive
  if (audio.currentTime >= audio.duration - 0.5 && playerLives > 0) {
    victoryTriggered = true;
    triggerVictory();
  }
}

async function triggerVictory() {
  gameOver = true;
  audio.pause();
  allowSpawning = false;
  
  // Clear game entities
  bullets = [];
  lasers = [];
  
  const victoryScreen = document.getElementById('victory-screen');
  const messageDiv = document.getElementById('victory-message');
  const statsDiv = document.getElementById('victory-stats');
  
  // Show victory screen
  victoryScreen.classList.add('show');
  
    statsDiv.innerHTML = `
     ‚ù§Ô∏è Lives Remaining: <strong>${playerLives}/3</strong>
  `;
  
  // Fetch victory message from external URL
  try {
    const url = getVictoryURL();
    const response = await fetch(url);
    
    if (!response.ok) throw new Error('Failed to load message');
    
    const text = await response.text();
    messageDiv.textContent = text;
    
    // Animate the message
    messageDiv.style.animation = 'slideUp 0.8s ease-out';
  } catch (error) {
    console.error('Error fetching victory message:', error);
    // Fallback message if fetch fails
    messageDiv.textContent = `üéä Congratulations! üéä

You've completed the Rhythm Dodger challenge!

Your reflexes are truly impressive!
Thank you for playing!`;
  }
}
/* ================= BEAT DETECTION ================= */
async function analyzeBeat() {
  try {
    statusDiv.textContent = "Loading song...";
    progressBar.style.width = "10%";
    audio.src = 'song.mp3';
    await new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error('Audio loading timeout'));
      }, 10000);
      audio.addEventListener('canplaythrough', () => {
        clearTimeout(timeout);
        resolve();
      }, { once: true });
      audio.addEventListener('error', (e) => {
        clearTimeout(timeout);
        reject(new Error('Failed to load song.mp3'));
      }, { once: true });
      audio.load();
    });
    statusDiv.textContent = "Creating audio context...";
    progressBar.style.width = "25%";
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    statusDiv.textContent = "Fetching audio data...";
    progressBar.style.width = "35%";
    const response = await fetch('song.mp3');
    const arrayBuffer = await response.arrayBuffer();
    statusDiv.textContent = "Decoding audio...";
    progressBar.style.width = "55%";
    const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
    statusDiv.textContent = "Analyzing beats...";
    progressBar.style.width = "75%";
    const channelData = audioBuffer.getChannelData(0);
    const sampleRate = audioBuffer.sampleRate;
    const beats = detectBeats(channelData, sampleRate);
    statusDiv.textContent = `Found ${beats.length} beats!`;
    progressBar.style.width = "90%";
    BEAT_TIMES = beats;
    if (beats.length > 1) {
      const intervals = [];
      for (let i = 1; i < Math.min(beats.length, 50); i++) {
        intervals.push(beats[i] - beats[i-1]);
      }
      const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
      const bpm = Math.round(60000 / avgInterval);
      statusDiv.textContent = `Ready! (~${bpm} BPM, ${beats.length} beats)`;
    }
    progressBar.style.width = "100%";
    setTimeout(() => {
      analysisComplete = true;
      loadingDiv.style.display = "none";
      mainMenu.classList.add('show'); // Show main menu instead
    }, 800);
  } catch (error) {
    console.error("Beat detection error:", error);
    statusDiv.innerHTML = `<span style='color:#ff4444'>‚ùå ${error.message}</span>`;
    progressBar.style.width = "0%";
  }
}
function detectBeats(channelData, sampleRate) {
  const beats = [];
  const windowSize = Math.floor(sampleRate * 0.05);
  const hopSize = Math.floor(windowSize / 2);
  const energyThreshold = 1.3;
  const energies = [];
  for (let i = 0; i < channelData.length - windowSize; i += hopSize) {
    let energy = 0;
    for (let j = 0; j < windowSize; j++) {
      const sample = channelData[i + j];
      energy += sample * sample;
    }
    energies.push(energy / windowSize);
  }
  const historySize = 43;
  for (let i = historySize; i < energies.length; i++) {
    const currentEnergy = energies[i];
    let avgEnergy = 0;
    for (let j = i - historySize; j < i; j++) {
      avgEnergy += energies[j];
    }
    avgEnergy /= historySize;
    if (currentEnergy > avgEnergy * energyThreshold) {
      const timeMs = (i * hopSize / sampleRate) * 1000;
      if (beats.length === 0 || timeMs - beats[beats.length - 1] > 200) {
        beats.push(timeMs);
      }
    }
  }
  if (beats.length > 4) {
    return refineBeatTiming(beats);
  }
  return beats;
}
function refineBeatTiming(rawBeats) {
  const intervals = [];
  for (let i = 1; i < rawBeats.length; i++) {
    intervals.push(rawBeats[i] - rawBeats[i-1]);
  }
  const histogram = {};
  const tolerance = 50;
  intervals.forEach(interval => {
    const bucket = Math.round(interval / tolerance) * tolerance;
    histogram[bucket] = (histogram[bucket] || 0) + 1;
  });
  let maxCount = 0;
  let dominantInterval = 500;
  for (const [interval, count] of Object.entries(histogram)) {
    if (count > maxCount) {
      maxCount = count;
      dominantInterval = parseFloat(interval);
    }
  }
  const refinedBeats = [rawBeats[0]];
  let expectedTime = rawBeats[0] + dominantInterval;
  for (let i = 1; i < rawBeats.length; i++) {
    const currentBeat = rawBeats[i];
    if (Math.abs(currentBeat - expectedTime) < tolerance) {
      refinedBeats.push(expectedTime);
      expectedTime += dominantInterval;
    } else if (currentBeat > expectedTime + tolerance) {
      refinedBeats.push(expectedTime);
      expectedTime += dominantInterval;
      i--;
    }
  }
  return refinedBeats;
}
/* ================= INPUT ================= */
const keys = {};
window.addEventListener("keydown", e => {
  keys[e.key] = true;
  if (e.key === "7" && gameStarted && !gameOver && !isDeathAnimationPlaying) {
    throwBothSides();
    lastItemThrowTime = Date.now(); // Reset timer when manually triggered
  }
  if ((e.key === " " || e.key === "ArrowUp") && player.isGrounded && !gameOver) {
    player.vy = player.jumpPower;
    player.isGrounded = false;
  }
});
window.addEventListener("keyup", e => keys[e.key] = false);
function startGameFromMenu() {
  mainMenu.classList.remove('show');
  startGame();
}
function startGame() {
  gameStarted = true;
  audioStarted = true;
  lastItemThrowTime = Date.now();
  currentBlockSpeed = BLOCK_SPEED + currentQuality.speedBonus;
  if (startDelayTimer) {
    clearTimeout(startDelayTimer);
    startDelayTimer = null;
  }
  audio.play().then(() => {
    audio.pause();
    audio.currentTime = 0;
  }).catch(err => {});
  allowSpawning = false;
  startDelayTimer = setTimeout(() => {
    allowSpawning = true;
    audio.play().catch(err => {});
    // Start video at the same time as the song and fade it in
    bgVideo.play().then(() => {
      bgVideo.classList.add('playing');
    }).catch(err => {
      console.warn("Video playback failed:", err);
    });
    startDelayTimer = null;
  }, START_DELAY);
}
/* ================= PLATFORM ================= */
function isOnPlatform(x, y) {
  const playerBottom = y + player.height;
  if (playerBottom >= PLATFORM_Y && playerBottom <= PLATFORM_Y + PLATFORM_HEIGHT) {
    if (x + player.width > PLATFORM_X && x < PLATFORM_X + PLATFORM_WIDTH) {
      return true;
    }
  }
  return false;
}
/* ================= SAFETY ================= */
function hasSafeGap(blocked) {
  let free = 0;
  for (let i = 0; i < LANE_COUNT; i++) {
    if (!blocked[i]) {
      free++;
      if (free >= MIN_SAFE_LANES) return true;
    } else free = 0;
  }
  return false;
}
function isLaneAvailable(lane, hitTime) {
  const occ = 400;
  const buffer = 300;
  const newStart = hitTime - occ / 2;
  const newEnd = hitTime + occ / 2 + buffer;
  const existing = laneReservations[lane];
  if (!existing) return true;
  const exStart = existing - occ / 2;
  const exEnd = existing + occ / 2 + buffer;
  return newEnd < exStart || newStart > exEnd;
}
function reserveLane(lane, hitTime) {
  laneReservations[lane] = hitTime;
}
/* ================= SPAWN ================= */
function spawnLaser(lane) {
  if (!allowSpawning) return;
  const hue = getHueForPhase();
  lasers.push({
    lane,
    time: 900,
    maxTime: 900,
    hue: hue,
    phase: Math.random() * Math.PI * 2
  });
}
function spawnBlock(lane, patternId) {
  if (!allowSpawning) return;
  const blockWidth = LANE_WIDTH - GAP_SIZE * 2;
  const blockHeight = blockWidth * 0.6;
  const hue = getHueForPhase();
  bullets.push({
    x: PLATFORM_X + lane * LANE_WIDTH + GAP_SIZE,
    y: -blockHeight,
    w: blockWidth,
    h: blockHeight,
    speed: currentBlockSpeed,
    hue: hue,
    patternId: patternId
  });
}
/* ================= PATTERN FUNCTIONS ================= */
function randomSingle() {
  const b = Array(LANE_COUNT).fill(false);
  b[Math.floor(Math.random() * LANE_COUNT)] = true;
  return b;
}
function randomMerged() {
  const b = Array(LANE_COUNT).fill(false);
  const s = Math.floor(Math.random() * (LANE_COUNT - 1));
  b[s] = b[s + 1] = true;
  return b;
}
function randomBurst() {
  const b = Array(LANE_COUNT).fill(false);
  for (let i = 0; i < 3; i++) b[Math.floor(Math.random() * LANE_COUNT)] = true;
  return b;
}
function randomWall() {
  const b = Array(LANE_COUNT).fill(true);
  const safe = Math.floor(Math.random() * LANE_COUNT);
  b[safe] = false;
  if (safe > 0) b[safe - 1] = false;
  else b[safe + 1] = false;
  return b;
}
function edgePattern() {
  const b = Array(LANE_COUNT).fill(false);
  b[0] = true;
  b[LANE_COUNT - 1] = true;
  return b;
}
function centerPattern() {
  const b = Array(LANE_COUNT).fill(false);
  const mid = Math.floor(LANE_COUNT / 2);
  b[mid] = true;
  if (mid > 0) b[mid - 1] = true;
  if (mid < LANE_COUNT - 1) b[mid + 1] = true;
  return b;
}
function alternatingPattern() {
  const b = Array(LANE_COUNT).fill(false);
  const startOffset = Math.random() > 0.5 ? 0 : 1;
  for (let i = startOffset; i < LANE_COUNT; i += 2) {
    b[i] = true;
  }
  const safeLane = startOffset === 0 ? 1 : 0;
  b[safeLane] = false;
  return b;
}
function cascadePattern() {
  const b = Array(LANE_COUNT).fill(false);
  const start = Math.floor(Math.random() * (LANE_COUNT - 2));
  b[start] = true;
  b[start + 1] = true;
  b[start + 2] = true;
  return b;
}
function sideSqueezePattern() {
  const b = Array(LANE_COUNT).fill(false);
  const leftSide = Math.random() > 0.5;
  if (leftSide) {
    b[0] = true;
    b[1] = true;
    if (LANE_COUNT > 3) b[2] = true;
  } else {
    b[LANE_COUNT - 1] = true;
    b[LANE_COUNT - 2] = true;
    if (LANE_COUNT > 3) b[LANE_COUNT - 3] = true;
  }
  return b;
}
function bookendsPattern() {
  const b = Array(LANE_COUNT).fill(false);
  b[0] = true;
  b[1] = true;
  b[LANE_COUNT - 1] = true;
  b[LANE_COUNT - 2] = true;
  return b;
}
function randomTriplePattern() {
  const b = Array(LANE_COUNT).fill(false);
  const indices = [];
  for (let i = 0; i < LANE_COUNT; i++) indices.push(i);
  for (let i = indices.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [indices[i], indices[j]] = [indices[j], indices[i]];
  }
  b[indices[0]] = true;
  b[indices[1]] = true;
  b[indices[2]] = true;
  return b;
}
function checkerPattern() {
  const b = Array(LANE_COUNT).fill(false);
  const first = Math.floor(Math.random() * (LANE_COUNT - 2));
  b[first] = true;
  b[first + 2] = true;
  return b;
}
function fullWallPattern() {
  const b = Array(LANE_COUNT).fill(true);
  const safe = Math.floor(Math.random() * LANE_COUNT);
  b[safe] = false;
  return b;
}
function movingWallPattern() {
  const b = Array(LANE_COUNT).fill(false);
  const safe = Math.floor(Math.random() * LANE_COUNT);
  for (let i = 0; i < LANE_COUNT; i++) {
    if (i !== safe) b[i] = true;
  }
  return b;
}
function zigzagPattern() {
  const b = Array(LANE_COUNT).fill(false);
  const direction = Math.random() > 0.5 ? 1 : -1;
  const start = direction > 0 ? 0 : LANE_COUNT - 1;
  for (let i = 0; i < 3 && (start + i * direction >= 0) && (start + i * direction < LANE_COUNT); i++) {
    b[start + i * direction] = true;
  }
  return b;
}
function snakePattern() {
  const b = Array(LANE_COUNT).fill(false);
  const offset = Math.floor(Math.random() * 2);
  b[offset] = true;
  b[offset + 2] = true;
  if (offset + 4 < LANE_COUNT) b[offset + 4] = true;
  return b;
}
function spiralPattern() {
  const b = Array(LANE_COUNT).fill(false);
  const type = Math.floor(Math.random() * 2);
  if (type === 0) {
    b[0] = true;
    b[LANE_COUNT - 1] = true;
  } else {
    const mid = Math.floor(LANE_COUNT / 2);
    b[mid - 1] = true;
    b[mid] = true;
    b[mid + 1] = true;
  }
  return b;
}
function shiftingWallPattern() {
  const b = Array(LANE_COUNT).fill(true);
  const gapSize = 2;
  const gapStart = Math.floor(Math.random() * (LANE_COUNT - gapSize + 1));
  for (let i = 0; i < gapSize; i++) {
    b[gapStart + i] = false;
  }
  return b;
}
function wavePattern() {
  const b = Array(LANE_COUNT).fill(false);
  const amplitude = 2;
  const center = Math.floor(LANE_COUNT / 2);
  b[center] = true;
  if (center - amplitude >= 0) b[center - amplitude] = true;
  if (center + amplitude < LANE_COUNT) b[center + amplitude] = true;
  return b;
}
function doubleWallPattern() {
  const b = Array(LANE_COUNT).fill(true);
  const gapPosition = 1 + Math.floor(Math.random() * (LANE_COUNT - 2));
  b[gapPosition] = false;
  return b;
}
function crossPattern() {
  const b = Array(LANE_COUNT).fill(false);
  b[0] = true;
  b[2] = true;
  b[LANE_COUNT - 1] = true;
  return b;
}
function cornerPattern() {
  const b = Array(LANE_COUNT).fill(false);
  b[0] = true;
  b[1] = true;
  b[LANE_COUNT - 1] = true;
  b[LANE_COUNT - 2] = true;
  return b;
}
function diamondPattern() {
  const b = Array(LANE_COUNT).fill(false);
  const mid = Math.floor(LANE_COUNT / 2);
  b[mid] = true;
  if (mid > 0) b[mid - 1] = true;
  if (mid < LANE_COUNT - 1) b[mid + 1] = true;
  return b;
}
function splitPattern() {
  const b = Array(LANE_COUNT).fill(false);
  const leftSide = Math.random() > 0.5;
  if (leftSide) {
    b[0] = true;
    b[1] = true;
  } else {
    b[LANE_COUNT - 1] = true;
    b[LANE_COUNT - 2] = true;
  }
  return b;
}
/* ================= PATTERN SCHEDULING ================= */
function schedulePatternForBeat(beatIndex) {
  if (beatIndex >= BEAT_TIMES.length || scheduledBeats.has(beatIndex)) return;
  scheduledBeats.add(beatIndex);
  const blockWidth = LANE_WIDTH - GAP_SIZE * 2;
  const blockHeight = blockWidth * 0.6;
  const travelDistance = HIT_Y + blockHeight;
  const travelFrames = travelDistance / currentBlockSpeed;
  const travelTimeMs = travelFrames * FRAME_TIME;
  const targetHitTime = BEAT_TIMES[beatIndex];
  const currentTime = audio.currentTime * 1000;
  const spawnDelay = targetHitTime - currentTime - travelTimeMs;
  if (spawnDelay < -100) return;
  let pattern = generatePattern();
  let available = pattern.map((b, i) => b && isLaneAvailable(i, targetHitTime));
  if (!available.some(v => v)) {
    const candidates = [];
    for (let i = 0; i < LANE_COUNT; i++) {
      if (isLaneAvailable(i, targetHitTime)) {
        candidates.push(i);
      }
    }
    if (candidates.length > 0) {
      const forcedLane = candidates[Math.floor(Math.random() * candidates.length)];
      available[forcedLane] = true;
    }
  }
  if (!hasSafeGap(available)) return;
  const patternId = `pattern_${beatIndex}_${Date.now()}`;
  available.forEach((spawn, lane) => {
    if (!spawn) return;
    reserveLane(lane, targetHitTime);
    setTimeout(() => {
      spawnLaser(lane);
      spawnBlock(lane, patternId);
    }, Math.max(0, spawnDelay));
  });
}
function generatePattern() {
  const intensity = Math.min(1, beatPulse + Math.random() * 0.3);
  if (currentPhase === 2) {
    if (intensity > 0.85) {
      const phase2HardPatterns = [shiftingWallPattern, doubleWallPattern, fullWallPattern, movingWallPattern];
      return phase2HardPatterns[Math.floor(Math.random() * phase2HardPatterns.length)]();
    }
    if (intensity > 0.7) {
      const phase2MediumPatterns = [zigzagPattern, wavePattern, snakePattern, cornerPattern, cascadePattern];
      return phase2MediumPatterns[Math.floor(Math.random() * phase2MediumPatterns.length)]();
    }
    if (intensity > 0.5) {
      const phase2EasyPatterns = [spiralPattern, crossPattern, diamondPattern, splitPattern, alternatingPattern, checkerPattern];
      return phase2EasyPatterns[Math.floor(Math.random() * phase2EasyPatterns.length)]();
    }
    if (Math.random() < 0.2) return Array(LANE_COUNT).fill(false);
    const defaultPatterns = [spiralPattern, crossPattern, splitPattern];
    return defaultPatterns[Math.floor(Math.random() * defaultPatterns.length)]();
  }
  if (intensity > 0.85) {
    const hardPatterns = [randomWall, fullWallPattern, movingWallPattern];
    return hardPatterns[Math.floor(Math.random() * hardPatterns.length)]();
  }
  if (intensity > 0.7) {
    const mediumHardPatterns = [randomBurst, cascadePattern, bookendsPattern, sideSqueezePattern];
    return mediumHardPatterns[Math.floor(Math.random() * mediumHardPatterns.length)]();
  }
  if (intensity > 0.5) {
    const mediumPatterns = [randomMerged, randomTriplePattern, alternatingPattern, centerPattern];
    return mediumPatterns[Math.floor(Math.random() * mediumPatterns.length)]();
  }
  if (Math.random() < 0.3) return Array(LANE_COUNT).fill(false);
  const patterns = [
    { fn: randomSingle, weight: 5 },
    { fn: randomMerged, weight: 3 },
    { fn: edgePattern, weight: 3 },
    { fn: checkerPattern, weight: 3 },
    { fn: centerPattern, weight: 3 },
    { fn: randomBurst, weight: 3 },
    { fn: cascadePattern, weight: 3 },
    { fn: alternatingPattern, weight: 3 }
  ];
  let r = Math.random() * patterns.reduce((s, p) => s + p.weight, 0);
  for (const p of patterns) {
    if ((r -= p.weight) <= 0) return p.fn();
  }
  return Array(LANE_COUNT).fill(false);
}
/* ================= DRAWING ================= */
function drawWalls() {
  const wallWidth = PLATFORM_MARGIN;
  const leftGrad = ctx.createLinearGradient(0, 0, wallWidth, 0);
  leftGrad.addColorStop(0, "#1a3a3a");
  leftGrad.addColorStop(0.15, "#144040");
  leftGrad.addColorStop(0.3, "#0a2525");
  leftGrad.addColorStop(0.7, "#0a2525");
  leftGrad.addColorStop(0.85, "#144040");
  leftGrad.addColorStop(1, "#1a3a3a");
  ctx.fillStyle = leftGrad;
  ctx.fillRect(0, 0, wallWidth, canvas.height);
  if (isHighQuality) {
    ctx.strokeStyle = "rgba(0, 255, 180, 0.3)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(1, 0);
    ctx.lineTo(1, canvas.height);
    ctx.stroke();
    ctx.strokeStyle = "rgba(0, 255, 180, 0.2)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(wallWidth - 1, 0);
    ctx.lineTo(wallWidth - 1, canvas.height);
    ctx.stroke();
  }
  const rightGrad = ctx.createLinearGradient(canvas.width - wallWidth, 0, canvas.width, 0);
  rightGrad.addColorStop(0, "#1a3a3a");
  rightGrad.addColorStop(0.15, "#144040");
  rightGrad.addColorStop(0.3, "#0a2525");
  rightGrad.addColorStop(0.7, "#0a2525");
  rightGrad.addColorStop(0.85, "#144040");
  rightGrad.addColorStop(1, "#1a3a3a");
  ctx.fillStyle = rightGrad;
  ctx.fillRect(canvas.width - wallWidth, 0, wallWidth, canvas.height);
  if (isHighQuality) {
    ctx.strokeStyle = "rgba(0, 255, 180, 0.2)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(canvas.width - wallWidth + 1, 0);
    ctx.lineTo(canvas.width - wallWidth + 1, canvas.height);
    ctx.stroke();
    ctx.strokeStyle = "rgba(0, 255, 180, 0.3)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(canvas.width - 1, 0);
    ctx.lineTo(canvas.width - 1, canvas.height);
    ctx.stroke();
  }
  const ceilingHeight = 40;
  const ceilingGrad = ctx.createLinearGradient(0, 0, 0, ceilingHeight);
  ceilingGrad.addColorStop(0, "#1a3a3a");
  ceilingGrad.addColorStop(0.3, "#0a2525");
  ceilingGrad.addColorStop(1, "#0a0a0a");
  ctx.fillStyle = ceilingGrad;
  ctx.fillRect(0, 0, canvas.width, ceilingHeight);
  if (isHighQuality) {
    ctx.strokeStyle = "rgba(0, 255, 180, 0.3)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, 1);
    ctx.lineTo(canvas.width, 1);
    ctx.stroke();
    ctx.strokeStyle = "rgba(0, 255, 180, 0.2)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, ceilingHeight - 1);
    ctx.lineTo(canvas.width, ceilingHeight - 1);
    ctx.stroke();
  }
}
function draw3DPlatform() {
  const glowHue = currentPhase === 2 ? 180 : 50;
  
  // Pulsing glow intensity based on beat
  const pulseIntensity = 0.6 + beatPulse * 0.4;
  const pulseSize = 2 + beatPulse * 3;
  
  ctx.save();
  ctx.strokeStyle = `hsla(${glowHue}, 100%, 60%, ${pulseIntensity})`;
  ctx.lineWidth = pulseSize;
  if (currentQuality.enableShadows) {
    ctx.shadowBlur = 8 + beatPulse * 20;
    ctx.shadowColor = `hsla(${glowHue}, 100%, 60%, ${pulseIntensity})`;
  }
  for (let i = 1; i < LANE_COUNT; i++) {
    const x = PLATFORM_X + i * LANE_WIDTH;
    ctx.beginPath();
    ctx.moveTo(x, 40);
    ctx.lineTo(x, PLATFORM_Y);
    ctx.stroke();
  }
  ctx.restore();
  ctx.save();
  ctx.strokeStyle = `hsla(${glowHue}, 100%, 60%, 0.8)`;
  ctx.lineWidth = 3 + beatPulse * 2;
  if (currentQuality.enableShadows) {
    ctx.shadowBlur = 15 + beatPulse * 15;
    ctx.shadowColor = `hsla(${glowHue}, 100%, 60%, 0.8)`;
  }
  ctx.beginPath();
  ctx.moveTo(PLATFORM_X, PLATFORM_Y);
  ctx.lineTo(PLATFORM_X + PLATFORM_WIDTH, PLATFORM_Y);
  ctx.stroke();
  ctx.restore();
  ctx.save();
  ctx.globalCompositeOperation = "lighter";
  const inwardGlowIntensity = 0.15 + beatPulse * 0.25;
  const leftInwardGlow = ctx.createLinearGradient(PLATFORM_X, 0, PLATFORM_X + 100, 0);
  leftInwardGlow.addColorStop(0, `hsla(${glowHue}, 100%, 60%, ${inwardGlowIntensity})`);
  leftInwardGlow.addColorStop(0.5, `hsla(${glowHue}, 100%, 55%, ${inwardGlowIntensity * 0.5})`);
  leftInwardGlow.addColorStop(1, `hsla(${glowHue}, 100%, 50%, 0)`);
  ctx.fillStyle = leftInwardGlow;
  ctx.fillRect(PLATFORM_X, 40, 100, PLATFORM_Y - 40);
  const rightInwardGlow = ctx.createLinearGradient(PLATFORM_X + PLATFORM_WIDTH - 100, 0, PLATFORM_X + PLATFORM_WIDTH, 0);
  rightInwardGlow.addColorStop(0, `hsla(${glowHue}, 100%, 50%, 0)`);
  rightInwardGlow.addColorStop(0.5, `hsla(${glowHue}, 100%, 55%, ${inwardGlowIntensity * 0.5})`);
  rightInwardGlow.addColorStop(1, `hsla(${glowHue}, 100%, 60%, ${inwardGlowIntensity})`);
  ctx.fillStyle = rightInwardGlow;
  ctx.fillRect(PLATFORM_X + PLATFORM_WIDTH - 100, 40, 100, PLATFORM_Y - 40);
  ctx.restore();
}
/* ================= MAIN LOOP ================= */
function update() {
  if (!analysisComplete) {
    requestAnimationFrame(update);
    return;
  }
  
  // Skip frames on mobile for better performance
  if (isMobile) {
    frameSkipCounter++;
    if (frameSkipCounter < 2) {
      requestAnimationFrame(update);
      return;
    }
    frameSkipCounter = 0;
  }
  
  // Clear canvas with transparency to show video background
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  frameCount++;
  beatPulse *= 0.85;
  if (gameStarted && audio && audio.duration) {
    updateProgressBar();
  }
  if (gameStarted && (!gameOver || isDeathAnimationPlaying)) {
    const currentTime = audio.currentTime * 1000;
    if (!isDeathAnimationPlaying) {
      checkPhase2Trigger();
      checkVictoryCondition();
      while (CURRENT_BEAT_INDEX < BEAT_TIMES.length && BEAT_TIMES[CURRENT_BEAT_INDEX] < currentTime) {
        CURRENT_BEAT_INDEX++;
        beatPulse = 1;
      }
      if (allowSpawning && BEAT_TIMES.length > 0) {
        const lastBeatTime = BEAT_TIMES[CURRENT_BEAT_INDEX - 1] || 0;
        const gap = currentTime - lastBeatTime;
        if (gap > 600) {
          BEAT_TIMES.splice(CURRENT_BEAT_INDEX, 0, currentTime);
          beatPulse = 1;
        }
      }
      if (allowSpawning) {
        const lookAheadTime = currentTime + 3000;
        for (let i = CURRENT_BEAT_INDEX; i < BEAT_TIMES.length; i++) {
          if (BEAT_TIMES[i] > lookAheadTime) break;
          schedulePatternForBeat(i);
        }
      }
      if (keys["ArrowLeft"] || mobileLeftPressed) player.vx -= player.accel;
      if (keys["ArrowRight"] || mobileRightPressed) player.vx += player.accel;
      player.vx *= player.friction;
      player.vx = Math.max(-player.maxSpeed, Math.min(player.maxSpeed, player.vx));
      player.x += player.vx;
      player.vy += player.gravity;
      player.y += player.vy;
      if (player.y + player.height >= PLATFORM_Y && player.vy >= 0) {
        if (isOnPlatform(player.x, player.y)) {
          player.y = PLATFORM_Y - player.height;
          player.vy = 0;
          player.isGrounded = true;
        } else {
          player.isGrounded = false;
        }
      } else {
        player.isGrounded = false;
      }
      if (player.y > canvas.height) {
        gameOver = true;
        audio.pause();
        bullets = [];
        lasers = [];
        phaseText.textContent = currentPhase === 2 ? "Phase 2" : "Phase 1";
        gameOverScreen.classList.add('show');
      }
    }
  }
  drawWalls();
  draw3DPlatform();
  for (let i = lasers.length - 1; i >= 0; i--) {
    const l = lasers[i];
    if (isDeathAnimationPlaying) {
      lasers.splice(i, 1);
      continue;
    }
    l.time -= FRAME_TIME;
    // Mobile: Use simplified laser rendering
    if (isMobile) {
      const progress = 1 - l.time / l.maxTime;
      const intensity = progress < 0.15 ? progress / 0.15 : 
                        progress < 0.8 ? 1 : (1 - progress) / 0.2;
      
      const x = PLATFORM_X + l.lane * LANE_WIDTH + LANE_WIDTH / 2;
      const blockWidth = LANE_WIDTH - GAP_SIZE * 2;
      
      ctx.save();
      ctx.globalAlpha = intensity * 0.6;
      ctx.fillStyle = `hsl(${l.hue}, 100%, 60%)`;
      ctx.fillRect(x - blockWidth/2, 40, blockWidth, PLATFORM_Y - 40);
      ctx.restore();
      
      if (l.time <= 0) lasers.splice(i, 1);
      continue; // Skip the complex desktop rendering
    }
    const progress = 1 - l.time / l.maxTime;
    let intensity = progress < 0.15 ? progress / 0.15 : progress < 0.8 ? 1 : (1 - progress) / 0.2;
    const beatPulseEffect = Math.sin(frameCount * (0.15 + progress * 0.25) + l.phase) * 0.5 + 0.5;
    const breathingPulse = Math.sin(frameCount * 0.08 + l.phase) * 0.3 + 0.7;
    const combinedPulse = beatPulseEffect * breathingPulse;
    const x = PLATFORM_X + l.lane * LANE_WIDTH + LANE_WIDTH / 2;
    const blockWidth = LANE_WIDTH - GAP_SIZE * 2;
    const widthMultiplier = progress < 0.15 ? 0.2 : progress < 0.5 ? 0.2 + ((progress - 0.15) / 0.35) * 0.8 : progress < 0.8 ? 1 : 1 - ((progress - 0.8) / 0.2) * 0.5;
    const pulsedBrightness = intensity * (0.2 + progress * 0.2) * (0.5 + combinedPulse * 0.3);
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    if (isHighQuality && intensity > 0.3) {
      for (let p = 0; p < 8; p++) {
        const angle = (p / 8) * Math.PI * 2 + frameCount * 0.02;
        const distance = (blockWidth * 0.4 + combinedPulse * 10) * widthMultiplier * (0.7 + Math.sin(frameCount * 0.05 + p) * 0.3);
        const px = x + Math.cos(angle) * distance;
        const particleSize = (15 + combinedPulse * 10) * widthMultiplier;
        const particleGrad = ctx.createRadialGradient(px, PLATFORM_Y / 2, 0, px, PLATFORM_Y / 2, particleSize);
        particleGrad.addColorStop(0, `hsla(${l.hue},100%,70%,${pulsedBrightness * 0.5})`);
        particleGrad.addColorStop(0.5, `hsla(${l.hue},100%,60%,${pulsedBrightness * 0.25})`);
        particleGrad.addColorStop(1, `hsla(${l.hue},100%,50%,0)`);
        ctx.fillStyle = particleGrad;
        ctx.fillRect(px - particleSize, 40, particleSize * 2, PLATFORM_Y - 40);
      }
    }
    const layerCount = currentQuality.laserLayers;
    const layers = isHighQuality ? [
      { width: blockWidth * 1.3, blur: 35, opacity: 0.3 },
      { width: blockWidth * 0.9 + combinedPulse * blockWidth * 0.1, blur: 28, opacity: 0.5 },
      { width: blockWidth + combinedPulse * blockWidth * 0.05, blur: 20, opacity: 0.7 },
      { width: blockWidth * 0.7 + combinedPulse * blockWidth * 0.05, blur: 15, opacity: 0.8 },
      { width: blockWidth * 0.4 + combinedPulse * blockWidth * 0.05, blur: 12, opacity: 0.9 }
    ] : [
      { width: blockWidth * 1.1, blur: 15, opacity: 0.4 },
      { width: blockWidth * 0.7, blur: 10, opacity: 0.7 }
    ];
    layers.forEach((layer, idx) => {
      const w = layer.width * widthMultiplier;
      if (currentQuality.enableShadows) {
        ctx.shadowBlur = layer.blur * intensity;
        ctx.shadowColor = `hsla(${l.hue},100%,${60 + idx * 5}%,${pulsedBrightness})`;
      }
      ctx.fillStyle = `hsla(${l.hue},100%,${60 + idx * 5}%,${pulsedBrightness * layer.opacity})`;
      ctx.fillRect(x - w / 2, 40, w, PLATFORM_Y - 40);
    });
    ctx.shadowBlur = 0;
    ctx.restore();
    if (l.time <= 0) lasers.splice(i, 1);
  }
  if (gameStarted) {
    drawHeartPlayer(player.x, player.y, player.width);
  }
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    if (!isDeathAnimationPlaying) {
      b.y += b.speed;
      if (b.y >= PLATFORM_Y && b.y < PLATFORM_Y + b.speed * 2) {
        if (!b.glowTriggered) {
          triggerScreenGlow(b.hue);
          createCollisionParticles(b.x, PLATFORM_Y, b.w, b.hue);
          b.glowTriggered = true;
          if (!impactSoundsPlaying.has(b.patternId)) {
            impactSoundsPlaying.add(b.patternId);
            playImpactSound();
            setTimeout(() => {
              impactSoundsPlaying.delete(b.patternId);
            }, 500);
          }
        }
      }
    }
  if (b.y < PLATFORM_Y + PLATFORM_HEIGHT && !isDeathAnimationPlaying) {
      const blurLength = (isHighQuality && !isMobile) ? 50 : 0;
      const blurStartY = Math.max(40, b.y - blurLength);
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      const blurGrad = ctx.createLinearGradient(b.x + b.w / 2, blurStartY, b.x + b.w / 2, b.y);
       if (isHighQuality) {
        const cx = b.x + b.w / 2, cy = b.y + b.h / 2;
        blurGrad.addColorStop(0.3, `hsla(${b.hue},100%,60%,0.15)`);
        blurGrad.addColorStop(0.6, `hsla(${b.hue},100%,60%,0.4)`);
        blurGrad.addColorStop(1, `hsla(${b.hue},100%,60%,0.7)`);
      } else {
        blurGrad.addColorStop(0, `hsla(${b.hue},100%,60%,0)`);
        blurGrad.addColorStop(1, `hsla(${b.hue},100%,60%,0.5)`);
      }
      ctx.fillStyle = blurGrad;
      ctx.fillRect(b.x, blurStartY, b.w, b.y - blurStartY);
      ctx.restore();
      if (isHighQuality) {
        const cx = b.x + b.w / 2, cy = b.y + b.h / 2;
        const r = Math.max(b.w, b.h) * 1.4;
        const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
        g.addColorStop(0, `hsla(${b.hue},100%,55%,0.4)`);
        g.addColorStop(0.5, `hsla(${b.hue},100%,50%,0.2)`);
        g.addColorStop(1, `hsla(${b.hue},100%,50%,0)`);
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        ctx.fillStyle = g;
        ctx.fillRect(cx - r, cy - r, r * 2, r * 2);
        ctx.restore();
      }
      if (currentQuality.enableShadows) {
        ctx.shadowBlur = 20;
        ctx.shadowColor = `hsl(${b.hue},100%,60%)`;
      }
      ctx.fillStyle = `hsl(${b.hue},100%,60%)`;
      ctx.fillRect(b.x, b.y, b.w, b.h);
      ctx.fillStyle = `hsl(${b.hue},100%,80%)`;
      ctx.fillRect(b.x + b.w * 0.3, b.y + b.h * 0.3, b.w * 0.4, b.h * 0.4);
      ctx.shadowBlur = 0;
    }
    if (gameStarted && !isDeathAnimationPlaying && player.x < b.x + b.w && player.x + player.width > b.x && player.y < b.y + b.h && player.y + player.height > b.y) {
      loseLife();
      bullets.splice(i, 1);
      continue;
    }
    if (b.y > canvas.height) bullets.splice(i, 1);
  }
  updateAndDrawParticles();
  updateAndDrawDissolveParticles();
  updateScreenGlow();
  updateAndDrawItems(); // Draw items on top of everything
  if (gameStarted && !gameOver && !isDeathAnimationPlaying) {
    checkItemThrow();
  }
  requestAnimationFrame(update);
}
function restart() {
  window.location.reload();
}
analyzeBeat();
requestAnimationFrame(update);
</script>
</body>
</html>